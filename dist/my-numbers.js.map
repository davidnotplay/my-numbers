{"version":3,"file":"my-numbers.js","mappings":"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","sources":["webpack://MyNumbers/webpack/universalModuleDefinition","webpack://MyNumbers/webpack/bootstrap","webpack://MyNumbers/webpack/runtime/define property getters","webpack://MyNumbers/webpack/runtime/hasOwnProperty shorthand","webpack://MyNumbers/./src/my-numbers.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MyNumbers\"] = factory();\n\telse\n\t\troot[\"MyNumbers\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * @preserve\n * My numbers\n * @author David Casado Mart√≠nez @davidnotplay\n * @license MIT\n * @see https://github.com/davidnotplay/my-numbers\n */\n\n/**\n * Regular expression for get the format parts.\n */\nconst formatRegex = new RegExp(\n  /^(#)?(\\+\\??)?((?:1([^\\d]))?1)?(?:([^\\d])(0+\\??))?(#)?$/\n)\n\n// this are invalid formats but the `formatRegex` regular expression accept as valids.\nconst invalidFormats = [\n  '#',\n  '##',\n  '#+#',\n  '+',\n  '#+?#',\n  '+?',\n  '#+?',\n  '+?#'\n]\n\n/**\n * Get the `num` number, written in scientific notfication, transformed in plain numeric string. \n */\nvar scientificToDecimal = function (num) {\n  var nsign = Math.sign(num)\n  //remove the sign\n  num = Math.abs(num)\n  //if the number is in scientific notation remove it\n  if (/\\d+\\.?\\d*e[+-]*\\d+/i.test(num)) {\n    let zero = '0'\n    let parts = String(num).toLowerCase().split('e')\n    let e = parts.pop()\n    let l = Math.abs(e)\n    let sign = e / l\n    let coeff_array = parts[0].split('.')\n\n    if (sign === -1) {\n      l = l - coeff_array[0].length\n      if (l < 0) {\n        num = coeff_array[0].slice(0, l) + '.' + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : '')\n      } \n      else {\n        num = zero + '.' + new Array(l + 1).join(zero) + coeff_array.join('')\n      }\n    } \n    else {\n      var dec = coeff_array[1]\n      if (dec) {\n        l = l - dec.length\n      }\n      if (l < 0) {\n        num = coeff_array[0] + dec.slice(0, l) + '.' + dec.slice(l)\n      } else {\n        num = coeff_array.join('') + new Array(l + 1).join(zero)\n      }\n    }\n  }\n  return nsign < 0 ? '-'+num : num\n}\n\n/**\n * Round the `num` number.\n * @param {float} num number to round\n * @param {int} decimalNumbers number of decimals\n * @return {float} Number rounded.\n */\nconst round = (num, decimalNumbers) => {\n  num = scientificToDecimal(num)\n  return +(scientificToDecimal(Math.round(num + `e+${decimalNumbers}`)) + `e-${decimalNumbers}`)\n}\n\n/**\n * Escape the regular expression characters of the `str` string.\n * @param {string} str string with you want escape\n * @return {string} String escaped\n */\nconst escapeRegEx = (str) => {\n  return str.replace(/([.+?*\\\\|()\\][{}])/g, r => '\\\\' + r[0])\n}\n\n/**\n * Parse the `formatStr` format and return a object with his components.\n * @param {string} formatStr String format\n * @return {object}\n */\nconst parseFormatStr = (formatStr) => {\n  if (invalidFormats.indexOf(formatStr) !== -1) {\n    return false\n  }\n\n  const result = formatRegex.exec(formatStr)\n\n  if (result === null) {\n    return false\n  }\n\n  const format = {}\n  const [\n    str, prefix, sign, integer, thousands, decimal, decimalNumbers, suffix\n  ] = result\n\n  if (str === '') {\n    return false\n  }\n\n  format.prefix = prefix === '#'\n  format.suffix = suffix === '#'\n  format.sign = sign === '+' || sign === '+?'\n  format.signOptional = format.sign && sign.endsWith('?')\n  format.integer = integer !== undefined\n  format.decimal = decimal || false\n  format.thousands = thousands || false\n  format.decimalOptional = (decimalNumbers || '').endsWith('?')\n  format.decimalNumbers = `${decimalNumbers || ''}`.length - (format.decimalOptional ? 1 : 0)\n\n\n  return format\n}\n\n/**\n * Apply the `modifier` modifier in the `num` number\n * @param {float} num Number for the mofifier\n * @param {float|function} modifier modifier will apply in the number\n * @param {boolean} inv Indicate if the conversion is str -> num or num -> str\n * @return {float} number with the modifier applied.\n */\nconst parseModifiers = (num, modifier, inv) => {\n  if (typeof modifier === 'number') {\n    return !inv ? num * modifier : num * (1/modifier)\n  }\n\n  return modifier(num, inv)\n}\n\n/**\n * Make the regulars expressions using the `formatObj` data.\n * @param {objec} formatObj Object with the format data\n * @return {object}\n *    - {RegExp} _regex: Regular expression necessary for parse the number.\n *    - {function} _replaceThousands: Function for replace the thousands number.\n */\nconst makeFormatRegex = (formatObj)  => {\n  let regex = ''\n\n  const pkeys = formatObj.prefix ? Object.keys(formatObj._prefixes).map(p => escapeRegEx(p)) : []\n  regex = `(${pkeys.join('|')})?`\n\n  regex = formatObj.sign ? `${regex}(\\\\+|-)?` : `${regex}()`\n\n  if (formatObj.integer) {\n    if (!formatObj.thousands) {\n      regex = `${regex}([0-9]+)`\n    } else {\n      regex = `${regex}((?:[1-9][0-9]{0,2}(?:\\\\${formatObj.thousands}[0-9]{3,3})*)|0+)`\n    }\n  } else {\n    regex = regex + '()'\n  }\n\n  if(formatObj.decimal) {\n    regex = `${regex}(?:\\\\${formatObj.decimal}([0-9]+))?`\n  }\n\n  const skeys = formatObj.suffix ? Object.keys(formatObj._suffixes).map(s => escapeRegEx(s)) : []\n  regex = `${regex}(${skeys.join('|')})?`\n\n  return {\n    _regex: new RegExp(`^${regex}$`),\n    _replaceThousands: int => parseInt(\n      formatObj.thousands ? int.replace(new RegExp(`\\\\${formatObj.thousands}`, 'g'), '') : int\n    )\n  }\n}\n\n/**\n * Parse the `number` string in a number using the `format` data.\n * @param {string} number number will be parsed\n * @param {object} format Format data\n * @return {int} number parsed.\n */\nconst parseNumber = (number, format) => {\n  const r = format._regex.exec(number)\n\n  if (r === null) {\n    return false\n  }\n\n  //eslint-disable-next-line no-unused-vars\n  const [ _, prefix, sign, integer, decimal, suffix ] = r\n  let num = 0\n\n  if (integer) {\n    num = format._replaceThousands(integer)\n  }\n\n  if (decimal) {\n    num += parseFloat(`0.${decimal}`)\n  }\n\n  if (sign === '-') {\n    num *= -1\n  }\n\n  if (prefix && format.prefix) {\n    num = parseModifiers(num, format._prefixes[prefix], false)\n  }\n\n  if (suffix && format.suffix) {\n    num = parseModifiers(num, format._suffixes[suffix], false)\n  }\n\n  return round(num, format.decimalNumbers)\n}\n\n\n/**\n * Transform a number in a number string formatted.\n * @param {int} num number will transform in a string\n * @param {object} format Format data\n * @param {string} prefix prefix will add to the string\n * @param {string} suffix suffix will add to the string.\n * @return {string} number formatted\n */\nconst stringify = (num, format, prefix = null, suffix = null) => {\n  if (prefix && format.prefix) {\n    const p = format._prefixes[prefix]\n    if (!p) {\n      throw new Error(`${prefix} prefix not found`)\n    }\n\n    num = parseModifiers(num, p, true)\n  }\n\n  if (suffix && format.suffix) {\n    const s = format._suffixes[suffix]\n\n    if (!s) {\n      throw new Error(`${suffix} suffix not found`)\n    }\n\n    num = parseModifiers(num, s, true)\n  }\n\n  num = round(num, format.decimalNumbers)\n  num = scientificToDecimal(num)\n  const [int, dec] = `${num}`.split(/\\./)\n  let strNum = ''\n\n  if(num < 0 && format.sign === false) {\n    return false\n  }\n\n  // integer part and no integer format\n  if (!format.integer && int !== '0') {\n    return false\n  }\n\n  // transform integer part\n  if (format.integer) {\n    strNum = int.split('').reverse().join('').match(/[0-9]{1,3}/g)\n      .join(format.thousands || '').split('').reverse().join('')\n  }\n\n  // decimal part\n  if (format.decimalNumbers > 0) {\n    if (!format.decimalOptional) {\n      const dln = (dec || '').length\n      const zeros = dln < format.decimalNumbers\n        ? '0'.repeat(format.decimalNumbers - dln)\n        : ''\n\n      strNum = `${strNum}${format.decimal}${dec || ''}${zeros}`\n    } else if (parseInt(dec || '0') !== 0) {\n      strNum = `${strNum}${format.decimal}${dec}`\n    }\n  }\n\n  if (format.sign) {\n    strNum = (num < 0 ? '-' : (!format.signOptional ? '+' : '')) + strNum\n  }\n\n  if (prefix && format.prefix) {\n    strNum = prefix + strNum\n  }\n\n  if (suffix && format.suffix) {\n    strNum = strNum + suffix\n  }\n\n  return strNum\n}\n\n\n/**\n * @param {string|array} formats Formats it will use for parse and stringify the numbers\n * @param {object} prefixes Object with the prefix and his values\n * @param {object} suffixes Object with the suffix and his values\n */\nconst MyNumbers = (formats, prefixes = {}, suffixes = {}) => {\n  const multi = Array.isArray(formats)\n  formats = multi ? formats : [formats]\n\n  const myNumber = {}\n  myNumber._fdata = {}\n\n  formats.forEach(formatStr => {\n    let format = parseFormatStr(formatStr)\n\n    // invalid format\n    if (!format) {\n      throw new Error(`The format '${formatStr}' is invalid.`)\n    }\n\n    format._prefixes = prefixes || {}\n    format._suffixes = suffixes || {}\n    format = Object.assign({}, format, makeFormatRegex(format))\n    myNumber._fdata[formatStr] = format\n  })\n\n  myNumber.parse = (number) => {\n    const r = {}\n\n    Object.keys(myNumber._fdata).forEach(formatStr => {\n      r[formatStr] = parseNumber(number, myNumber._fdata[formatStr])\n    })\n    return multi ? r : r[formats[0]]\n  }\n\n  myNumber.stringify = (number, prefix = null, suffix = null) => {\n    const r = {}\n\n    Object.keys(myNumber._fdata).forEach(formatStr => {\n      r[formatStr] = stringify(number, myNumber._fdata[formatStr], prefix, suffix)\n    })\n\n    return multi ? r : r[formats[0]]\n\n  }\n\n  return myNumber\n}\n\nexport default MyNumbers\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","formatRegex","RegExp","invalidFormats","scientificToDecimal","num","nsign","Math","sign","abs","test","parts","String","toLowerCase","split","e","pop","l","coeff_array","length","slice","zero","Array","join","dec","round","decimalNumbers","concat","escapeRegEx","str","replace","r","parseModifiers","modifier","inv","formats","prefixes","arguments","undefined","suffixes","multi","isArray","myNumber","forEach","formatStr","format","indexOf","result","exec","_result","_slicedToArray","prefix","integer","thousands","decimal","suffix","signOptional","endsWith","decimalOptional","parseFormatStr","Error","_prefixes","_suffixes","assign","formatObj","regex","pkeys","keys","map","p","skeys","s","_regex","_replaceThousands","int","parseInt","makeFormatRegex","_fdata","parse","number","_r2","parseFloat","parseNumber","stringify","_split2","strNum","reverse","match","dln","zeros","repeat"],"sourceRoot":""}