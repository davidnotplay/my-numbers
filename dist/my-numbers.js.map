{"version":3,"file":"my-numbers.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAmB,UAAID,IAEvBD,EAAgB,UAAIC,IARtB,CASGK,MAAM,WACT,yBCTA,IAAIC,EAAsB,CCA1B,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,qpDCWlF,IAAMI,EAAc,IAAIC,OACtB,0DAIIC,EAAiB,CACrB,IACA,KACA,MACA,IACA,OACA,KACA,MACA,OAoCIC,EAAQ,SAACC,EAAKC,GAClB,QAlC0B,SAAAD,GAE1B,GAAI,sBAAsBE,KAAKF,EAAIG,YAAa,CAC9C,IACMC,EAAQC,OAAOL,GAAKM,cAAcC,MAAM,KACxCC,EAAcJ,EAAMK,MACtBC,EAAWC,KAAKC,IAAIJ,GAClBK,EAAOL,EAAcE,EACrBI,EAAaV,EAAM,GAAGG,MAAM,KAElC,IAAc,IAAVM,EACFC,EAAW,GAAKH,KAAKC,IAAIE,EAAW,IACpCd,EAAM,IAAH,OATQ,IASR,YAAkB,IAAIe,MAAML,GAAUM,KAT9B,KAS2CF,EAAWE,KAAK,SACjE,CACL,IAAMC,EAAWH,EAAW,GAExBG,IACFP,GAAsBO,EAASC,QAGjClB,EAAMc,EAAWE,KAAK,IAAM,IAAID,MAAML,EAAW,GAAGM,KAjBzC,MAqBf,OAAOhB,EAUEmB,CAAoBR,KAAKZ,MAAMC,EAAM,KAAH,OAAQC,KAA1C,YAAoEA,KAQzEmB,EAAc,SAACC,GACnB,OAAOA,EAAIC,QAAQ,uBAAuB,SAAAC,GAAC,MAAI,KAAOA,EAAE,OAQpDC,EAAiB,SAACC,GACtB,IAA2C,IAAvC3B,EAAe4B,QAAQD,GACzB,OAAO,EAGT,IAAME,EAAS/B,EAAYgC,KAAKH,GAEhC,GAAe,OAAXE,EACF,OAAO,EAGT,IAAME,EAAS,GACf,IAEIF,EAFJ,GACEN,EADF,KACOS,EADP,KACejB,EADf,KACqBkB,EADrB,KAC8BC,EAD9B,KACyCC,EADzC,KACkDhC,EADlD,KACkEiC,EADlE,KAIA,MAAY,KAARb,IAIJQ,EAAOC,OAAoB,MAAXA,EAChBD,EAAOK,OAAoB,MAAXA,EAChBL,EAAOhB,KAAgB,MAATA,GAAyB,OAATA,EAC9BgB,EAAOM,aAAeN,EAAOhB,MAAQA,EAAKuB,SAAS,KACnDP,EAAOE,aAAsBM,IAAZN,EACjBF,EAAOI,QAAUA,IAAW,EAC5BJ,EAAOG,UAAYA,IAAa,EAChCH,EAAOS,iBAAmBrC,GAAkB,IAAImC,SAAS,KACzDP,EAAO5B,eAAiB,UAAGA,GAAkB,IAAKiB,QAAUW,EAAOS,gBAAkB,EAAI,GAGlFT,IAUHU,EAAiB,SAACvC,EAAKwC,EAAUC,GACrC,MAAwB,iBAAbD,EACDC,EAAuBzC,GAAO,EAAEwC,GAA1BxC,EAAMwC,EAGfA,EAASxC,EAAKyC,IAUjBC,EAAkB,SAACC,GACvB,IAAIC,EAAQ,GAENC,EAAQF,EAAUb,OAAS3C,OAAO2D,KAAKH,EAAUI,WAAWC,KAAI,SAAAC,GAAC,OAAI7B,EAAY6B,MAAM,GAC7FL,EAAQ,IAAH,OAAOC,EAAM7B,KAAK,KAAlB,MAEL4B,EAAQD,EAAU9B,KAAV,UAAoB+B,EAApB,sBAAyCA,EAAzC,MAEJD,EAAUZ,QAIVa,EAHGD,EAAUX,UAGL,GAAH,OAAMY,EAAN,mCAAsCD,EAAUX,UAAhD,qBAFG,GAAH,OAAMY,EAAN,YAKPA,GAAgB,KAGfD,EAAUV,UACXW,EAAQ,GAAH,OAAMA,EAAN,gBAAmBD,EAAUV,QAA7B,eAGP,IAAMiB,EAAQP,EAAUT,OAAS/C,OAAO2D,KAAKH,EAAUQ,WAAWH,KAAI,SAAAI,GAAC,OAAIhC,EAAYgC,MAAM,GAG7F,OAFAR,EAAQ,GAAH,OAAMA,EAAN,YAAeM,EAAMlC,KAAK,KAA1B,MAEE,CACLqC,OAAQ,IAAIxD,OAAJ,WAAe+C,EAAf,MACRU,kBAAmB,SAAAC,GAAG,OAAIC,SACxBb,EAAUX,UAAYuB,EAAIjC,QAAQ,IAAIzB,OAAJ,YAAgB8C,EAAUX,WAAa,KAAM,IAAMuB,MAWrFE,EAAc,SAACC,EAAQ7B,GAC3B,IAAMN,EAAIM,EAAOwB,OAAOzB,KAAK8B,GAE7B,GAAU,OAANnC,EACF,OAAO,EAIT,QAAsDA,EAAtD,GAAWO,GAAX,WAAmBjB,EAAnB,KAAyBkB,EAAzB,KAAkCE,EAAlC,KAA2CC,EAA3C,KACIlC,EAAM,EAsBV,OApBI+B,IACF/B,EAAM6B,EAAOyB,kBAAkBvB,IAG7BE,IACFjC,GAAO2D,WAAW,KAAD,OAAM1B,KAGZ,MAATpB,IACFb,IAAQ,GAGN8B,GAAUD,EAAOC,SACnB9B,EAAMuC,EAAevC,EAAK6B,EAAOkB,UAAUjB,IAAS,IAGlDI,GAAUL,EAAOK,SACnBlC,EAAMuC,EAAevC,EAAK6B,EAAOsB,UAAUjB,IAAS,IAG/CnC,EAAMC,EAAK6B,EAAO5B,iBAYrB2D,EAAY,SAAC5D,EAAK6B,GAAyC,IAAjCC,EAAiC,uDAAxB,KAAMI,EAAkB,uDAAT,KACtD,GAAIJ,GAAUD,EAAOC,OAAQ,CAC3B,IAAMmB,EAAIpB,EAAOkB,UAAUjB,GAC3B,IAAKmB,EACH,MAAM,IAAIY,MAAJ,UAAa/B,EAAb,sBAGR9B,EAAMuC,EAAevC,EAAKiD,GAAG,GAG/B,GAAIf,GAAUL,EAAOK,OAAQ,CAC3B,IAAMkB,EAAIvB,EAAOsB,UAAUjB,GAE3B,IAAKkB,EACH,MAAM,IAAIS,MAAJ,UAAa3B,EAAb,sBAGRlC,EAAMuC,EAAevC,EAAKoD,GAAG,GAG/BpD,EAAMD,EAAMC,EAAK6B,EAAO5B,gBACxB,MAAmB,UAAGD,GAAMO,MAAM,MAAlC,SAAOgD,EAAP,KAAYO,EAAZ,KACIC,EAAS,GAEb,GAAG/D,EAAM,IAAqB,IAAhB6B,EAAOhB,KACnB,OAAO,EAIT,IAAKgB,EAAOE,SAAmB,MAARwB,EACrB,OAAO,EAUT,GANI1B,EAAOE,UACTgC,EAASR,EAAIhD,MAAM,IAAIyD,UAAUhD,KAAK,IAAIiD,MAAM,eAC7CjD,KAAKa,EAAOG,WAAa,IAAIzB,MAAM,IAAIyD,UAAUhD,KAAK,KAIvDa,EAAO5B,eAAiB,EAC1B,GAAK4B,EAAOS,gBAOwB,IAAzBkB,SAASM,GAAO,OACzBC,EAAS,GAAH,OAAMA,GAAN,OAAelC,EAAOI,SAAtB,OAAgC6B,QARX,CAC3B,IAAMI,GAAOJ,GAAO,IAAI5C,OAClBiD,EAAQD,EAAMrC,EAAO5B,eACvB,IAAImE,OAAOvC,EAAO5B,eAAiBiE,GACnC,GAEJH,EAAS,GAAH,OAAMA,GAAN,OAAelC,EAAOI,SAAtB,OAAgC6B,GAAO,IAAvC,OAA4CK,GAkBtD,OAZItC,EAAOhB,OACTkD,GAAU/D,EAAM,EAAI,IAAQ6B,EAAOM,aAAqB,GAAN,KAAa4B,GAG7DjC,GAAUD,EAAOC,SACnBiC,EAASjC,EAASiC,GAGhB7B,GAAUL,EAAOK,SACnB6B,GAAkB7B,GAGb6B,GAqDT,QA5CkB,SAACM,GAA0C,IAAjCC,EAAiC,uDAAtB,GAAIC,EAAkB,uDAAP,GAC9CC,EAAQzD,MAAM0D,QAAQJ,GAGtBK,EAAW,CACjBA,OAAkB,IAoClB,OAvCAL,EAAUG,EAAQH,EAAU,CAACA,IAKrBM,SAAQ,SAAAlD,GACd,IAAII,EAASL,EAAeC,GAG5B,IAAKI,EACH,MAAM,IAAIgC,MAAJ,sBAAyBpC,EAAzB,kBAGRI,EAAOkB,UAAYuB,GAAY,GAC/BzC,EAAOsB,UAAYoB,GAAY,GAC/B1C,EAAS,EAAH,KAAQA,GAAWa,EAAgBb,IACzC6C,EAASE,OAAOnD,GAAaI,KAG/B6C,EAASG,MAAQ,SAACnB,GAChB,IAAMnC,EAAI,GAKV,OAHApC,OAAO2D,KAAK4B,EAASE,QAAQD,SAAQ,SAAAlD,GACnCF,EAAEE,GAAagC,EAAYC,EAAQgB,EAASE,OAAOnD,OAE9C+C,EAAQjD,EAAIA,EAAE8C,EAAQ,KAG/BK,EAASd,UAAY,SAACF,GAAyC,IAAjC5B,EAAiC,uDAAxB,KAAMI,EAAkB,uDAAT,KAC9CX,EAAI,GAMV,OAJApC,OAAO2D,KAAK4B,EAASE,QAAQD,SAAQ,SAAAlD,GACnCF,EAAEE,GAAamC,EAAUF,EAAQgB,EAASE,OAAOnD,GAAYK,EAAQI,MAGhEsC,EAAQjD,EAAIA,EAAE8C,EAAQ,KAIxBK","sources":["webpack://MyNumbers/webpack/universalModuleDefinition","webpack://MyNumbers/webpack/bootstrap","webpack://MyNumbers/webpack/runtime/define property getters","webpack://MyNumbers/webpack/runtime/hasOwnProperty shorthand","webpack://MyNumbers/./src/my-numbers.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MyNumbers\"] = factory();\n\telse\n\t\troot[\"MyNumbers\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * @preserve\n * My numbers\n * @author David Casado MartÃ­nez @davidnotplay\n * @license MIT\n * @see https://github.com/davidnotplay/my-numbers\n */\n\n/**\n * Regular expression for get the format parts.\n */\nconst formatRegex = new RegExp(\n  /^(#)?(\\+\\??)?((?:1([^\\d]))?1)?(?:([^\\d])(0+\\??))?(#)?$/\n)\n\n// this are invalid formats but the `formatRegex` regular expression accept as valids.\nconst invalidFormats = [\n  '#',\n  '##',\n  '#+#',\n  '+',\n  '#+?#',\n  '+?',\n  '#+?',\n  '+?#'\n]\n\nconst scientificToDecimal = num => {\n  // if the number is in scientific notation remove it\n  if (/\\d+\\.?\\d*e[+-]*\\d+/i.test(num.toString())) {\n    const zero = '0'\n    const parts = String(num).toLowerCase().split('e') // split into coeff and exponent\n    const exponencial = parts.pop() // store the exponential part\n    let expZeros = Math.abs(exponencial) // get the number of zeros\n    const sign = exponencial / expZeros\n    const coeffArray = parts[0].split('.')\n\n    if (sign === -1) {\n      coeffArray[0] = Math.abs(coeffArray[0])\n      num = `-${ zero }.${ new Array(expZeros).join(zero) + coeffArray.join('') }`\n    } else {\n      const decrease = coeffArray[1]\n\n      if (decrease) {\n        expZeros = expZeros - decrease.length\n      }\n\n      num = coeffArray.join('') + new Array(expZeros + 1).join(zero)\n    }\n  }\n\n  return num\n}\n\n/**\n * Round the `num` number.\n * @param {float} num number to round\n * @param {int} decimalNumbers number of decimals\n * @return {float} Number rounded.\n */\nconst round = (num, decimalNumbers) => {\n  return +(scientificToDecimal(Math.round(num + `e+${decimalNumbers}`)) + `e-${decimalNumbers}`)\n}\n\n/**\n * Escape the regular expression characters of the `str` string.\n * @param {string} str string with you want escape\n * @return {string} String escaped\n */\nconst escapeRegEx = (str) => {\n  return str.replace(/([.+?*\\\\|()\\][{}])/g, r => '\\\\' + r[0])\n}\n\n/**\n * Parse the `formatStr` format and return a object with his components.\n * @param {string} formatStr String format\n * @return {object}\n */\nconst parseFormatStr = (formatStr) => {\n  if (invalidFormats.indexOf(formatStr) !== -1) {\n    return false\n  }\n\n  const result = formatRegex.exec(formatStr)\n\n  if (result === null) {\n    return false\n  }\n\n  const format = {}\n  const [\n    str, prefix, sign, integer, thousands, decimal, decimalNumbers, suffix\n  ] = result\n\n  if (str === '') {\n    return false\n  }\n\n  format.prefix = prefix === '#'\n  format.suffix = suffix === '#'\n  format.sign = sign === '+' || sign === '+?'\n  format.signOptional = format.sign && sign.endsWith('?')\n  format.integer = integer !== undefined\n  format.decimal = decimal || false\n  format.thousands = thousands || false\n  format.decimalOptional = (decimalNumbers || '').endsWith('?')\n  format.decimalNumbers = `${decimalNumbers || ''}`.length - (format.decimalOptional ? 1 : 0)\n\n\n  return format\n}\n\n/**\n * Apply the `modifier` modifier in the `num` number\n * @param {float} num Number for the mofifier\n * @param {float|function} modifier modifier will apply in the number\n * @param {boolean} inv Indicate if the conversion is str -> num or num -> str\n * @return {float} number with the modifier applied.\n */\nconst parseModifiers = (num, modifier, inv) => {\n  if (typeof modifier === 'number') {\n    return !inv ? num * modifier : num * (1/modifier)\n  }\n\n  return modifier(num, inv)\n}\n\n/**\n * Make the regulars expressions using the `formatObj` data.\n * @param {objec} formatObj Object with the format data\n * @return {object}\n *    - {RegExp} _regex: Regular expression necessary for parse the number.\n *    - {function} _replaceThousands: Function for replace the thousands number.\n */\nconst makeFormatRegex = (formatObj)  => {\n  let regex = ''\n\n  const pkeys = formatObj.prefix ? Object.keys(formatObj._prefixes).map(p => escapeRegEx(p)) : []\n  regex = `(${pkeys.join('|')})?`\n\n  regex = formatObj.sign ? `${regex}(\\\\+|-)?` : `${regex}()`\n\n  if (formatObj.integer) {\n    if (!formatObj.thousands) {\n      regex = `${regex}([0-9]+)`\n    } else {\n      regex = `${regex}((?:[1-9][0-9]{0,2}(?:\\\\${formatObj.thousands}[0-9]{3,3})*)|0+)`\n    }\n  } else {\n    regex = regex + '()'\n  }\n\n  if(formatObj.decimal) {\n    regex = `${regex}(?:\\\\${formatObj.decimal}([0-9]+))?`\n  }\n\n  const skeys = formatObj.suffix ? Object.keys(formatObj._suffixes).map(s => escapeRegEx(s)) : []\n  regex = `${regex}(${skeys.join('|')})?`\n\n  return {\n    _regex: new RegExp(`^${regex}$`),\n    _replaceThousands: int => parseInt(\n      formatObj.thousands ? int.replace(new RegExp(`\\\\${formatObj.thousands}`, 'g'), '') : int\n    )\n  }\n}\n\n/**\n * Parse the `number` string in a number using the `format` data.\n * @param {string} number number will be parsed\n * @param {object} format Format data\n * @return {int} number parsed.\n */\nconst parseNumber = (number, format) => {\n  const r = format._regex.exec(number)\n\n  if (r === null) {\n    return false\n  }\n\n  //eslint-disable-next-line no-unused-vars\n  const [ _, prefix, sign, integer, decimal, suffix ] = r\n  let num = 0\n\n  if (integer) {\n    num = format._replaceThousands(integer)\n  }\n\n  if (decimal) {\n    num += parseFloat(`0.${decimal}`)\n  }\n\n  if (sign === '-') {\n    num *= -1\n  }\n\n  if (prefix && format.prefix) {\n    num = parseModifiers(num, format._prefixes[prefix], false)\n  }\n\n  if (suffix && format.suffix) {\n    num = parseModifiers(num, format._suffixes[suffix], false)\n  }\n\n  return round(num, format.decimalNumbers)\n}\n\n\n/**\n * Transform a number in a number string formatted.\n * @param {int} num number will transform in a string\n * @param {object} format Format data\n * @param {string} prefix prefix will add to the string\n * @param {string} suffix suffix will add to the string.\n * @return {string} number formatted\n */\nconst stringify = (num, format, prefix = null, suffix = null) => {\n  if (prefix && format.prefix) {\n    const p = format._prefixes[prefix]\n    if (!p) {\n      throw new Error(`${prefix} prefix not found`)\n    }\n\n    num = parseModifiers(num, p, true)\n  }\n\n  if (suffix && format.suffix) {\n    const s = format._suffixes[suffix]\n\n    if (!s) {\n      throw new Error(`${suffix} suffix not found`)\n    }\n\n    num = parseModifiers(num, s, true)\n  }\n\n  num = round(num, format.decimalNumbers)\n  const [int, dec] = `${num}`.split(/\\./)\n  let strNum = ''\n\n  if(num < 0 && format.sign === false) {\n    return false\n  }\n\n  // integer part and no integer format\n  if (!format.integer && int !== '0') {\n    return false\n  }\n\n  // transform integer part\n  if (format.integer) {\n    strNum = int.split('').reverse().join('').match(/[0-9]{1,3}/g)\n      .join(format.thousands || '').split('').reverse().join('')\n  }\n\n  // decimal part\n  if (format.decimalNumbers > 0) {\n    if (!format.decimalOptional) {\n      const dln = (dec || '').length\n      const zeros = dln < format.decimalNumbers\n        ? '0'.repeat(format.decimalNumbers - dln)\n        : ''\n\n      strNum = `${strNum}${format.decimal}${dec || ''}${zeros}`\n    } else if (parseInt(dec || '0') !== 0) {\n      strNum = `${strNum}${format.decimal}${dec}`\n    }\n  }\n\n  if (format.sign) {\n    strNum = (num < 0 ? '-' : (!format.signOptional ? '+' : '')) + strNum\n  }\n\n  if (prefix && format.prefix) {\n    strNum = prefix + strNum\n  }\n\n  if (suffix && format.suffix) {\n    strNum = strNum + suffix\n  }\n\n  return strNum\n}\n\n\n/**\n * @param {string|array} formats Formats it will use for parse and stringify the numbers\n * @param {object} prefixes Object with the prefix and his values\n * @param {object} suffixes Object with the suffix and his values\n */\nconst MyNumbers = (formats, prefixes = {}, suffixes = {}) => {\n  const multi = Array.isArray(formats)\n  formats = multi ? formats : [formats]\n\n  const myNumber = {}\n  myNumber._fdata = {}\n\n  formats.forEach(formatStr => {\n    let format = parseFormatStr(formatStr)\n\n    // invalid format\n    if (!format) {\n      throw new Error(`The format '${formatStr}' is invalid.`)\n    }\n\n    format._prefixes = prefixes || {}\n    format._suffixes = suffixes || {}\n    format = { ...format, ...makeFormatRegex(format) }\n    myNumber._fdata[formatStr] = format\n  })\n\n  myNumber.parse = (number) => {\n    const r = {}\n\n    Object.keys(myNumber._fdata).forEach(formatStr => {\n      r[formatStr] = parseNumber(number, myNumber._fdata[formatStr])\n    })\n    return multi ? r : r[formats[0]]\n  }\n\n  myNumber.stringify = (number, prefix = null, suffix = null) => {\n    const r = {}\n\n    Object.keys(myNumber._fdata).forEach(formatStr => {\n      r[formatStr] = stringify(number, myNumber._fdata[formatStr], prefix, suffix)\n    })\n\n    return multi ? r : r[formats[0]]\n\n  }\n\n  return myNumber\n}\n\nexport default MyNumbers\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","formatRegex","RegExp","invalidFormats","round","num","decimalNumbers","test","toString","parts","String","toLowerCase","split","exponencial","pop","expZeros","Math","abs","sign","coeffArray","Array","join","decrease","length","scientificToDecimal","escapeRegEx","str","replace","r","parseFormatStr","formatStr","indexOf","result","exec","format","prefix","integer","thousands","decimal","suffix","signOptional","endsWith","undefined","decimalOptional","parseModifiers","modifier","inv","makeFormatRegex","formatObj","regex","pkeys","keys","_prefixes","map","p","skeys","_suffixes","s","_regex","_replaceThousands","int","parseInt","parseNumber","number","parseFloat","stringify","Error","dec","strNum","reverse","match","dln","zeros","repeat","formats","prefixes","suffixes","multi","isArray","myNumber","forEach","_fdata","parse"],"sourceRoot":""}